#
# Cookbook Name:: {{app.name}}
# Library:: common_lib
#
# {{app.publisher.packaging_copyright}}
#

require 'time'

class Chef::Recipe::{{app.chefName}}

    def self.define_app (chef)
        base = Chef::Recipe::Base
        app = {
            :name => '{{app.name}}',
            :hostname => %x(hostname).strip,
            :ipaddress => chef.node['ipaddress'],
            :uniq => [],
            :rand => [],
            :chef_user => base.chef_user,
            :chef_user_home => base.chef_user_home,
            :mail_user => 'cloudos_system_mailer',
            :mail_password => base.password('system_mailer')
        }
        app[:service_name] = app[:name].gsub('-', '_').gsub(/\W/, '')

        (0...9).each do |n|
        app[:uniq] << base.password("{{app.name}}_#{n}")
        app[:rand] << SecureRandom.hex(64)
        end

        {{#if app.passwords}}
        app[:passwords] = {}
            {{#each app.passwords}}
        app[:passwords]['{{this}}'] = base.password '{{this}}'
            {{/each}}
        {{/if}}

        {{#if app.web.mount}}
        app[:mount] = '{{app.web.mount}}'
        {{/if}}

        app[:databag] = {}
        app[:databag_replacements] = {}

        # If we have a ports databag, define it and populate replacements
        begin
            app[:databag][:ports] = chef.data_bag_item('{{app.name}}', 'ports')
            app[:databag][:ports].each do |bagkey, bagvalue|
                define_databag_replacements app[:databag_replacements], "@databag[ports]", bagkey, bagvalue
            end
        rescue => e
            puts "{{app.name}}/ports databag not found or error reading: #{e}"
        end

        # If we have a base databag, define it and populate replacements, then set hostname
        begin
            app[:databag][:base] = chef.data_bag_item('{{app.name}}', 'base')
            app[:databag][:base].each do |bagkey, bagvalue|
                define_databag_replacements app[:databag_replacements], "@databag[base]", bagkey, bagvalue
            end

            # set the hostname based on values in the base databag
            hostname = app[:databag][:base]['hostname']
            app[:domain] = parent_domain = app[:databag][:base]['parent_domain']
            fqdn = "#{hostname}.#{parent_domain}"

            # But only if we are already this hostname -- the install.sh script should set the hostname for us
            raise "Please run with install.sh: system hostname (#{app[:hostname]}) didn't match base databag value (#{fqdn})" unless app[:hostname] == fqdn

            base.set_hostname self, fqdn

        rescue => e
            puts "{{app.name}}/base databag not found or error reading: #{e}"
        end

        # If there is a cloudos-init databag, define it as @cloudos
        begin
            app[:cloudos_databag] = chef.data_bag_item('cloudos', 'init')
            app[:cloudos_databag].each do |bagkey, bagvalue|
                define_databag_replacements app[:databag_replacements], "@cloudos", bagkey, bagvalue
            end
        rescue => e
            puts "cloudos/init databag not found or error reading: #{e}"
        end

        app[:domain] ||= %x(hostname -d).strip

        {{#if app.databags}}
            {{#each app.databags}}
        app[:databag][:{{ident name}}] = chef.data_bag_item('{{app.name}}', '{{name}}')
        app[:databag][:{{ident name}}].each do |bagkey, bagvalue|
            define_databag_replacements app[:databag_replacements], "@databag[{{ident name}}]", bagkey, bagvalue
        end
            {{/each}}
        {{/if}}

        {{#if app.web}}
          {{#if app.web.mount}}
        app[:mount] = subst_string('{{app.web.mount}}', app)
          {{else}}
            {{#if app.web.is_separate_hostname}}
        app[:mount] = ''
            {{else}}
        app[:mount] = subst_string('{{app.name}}', app)
            {{/if}}
          {{/if}}

          {{#if app.web.local_mount}}
        app[:local_mount] = subst_string('{{app.web.local_mount}}', app)
          {{else}}
        app[:local_mount] = subst_string('{{app.web.local_mount}}', app)
          {{/if}}
        {{else}}
        app[:mount] = app[:local_mount] = ''
        {{/if}}

        init_user chef, app

        return app
    end

    DATABAG_SIMPLE_TYPES = [ String, Fixnum, TrueClass, FalseClass ]
    def self.define_databag_replacements(hash, base, bagkey, bagvalue)
        if DATABAG_SIMPLE_TYPES.include?(bagvalue.class)
hash["#{base}[#{bagkey}]"] = bagvalue.to_s
        elsif bagvalue
            bagvalue.each do |subkey, subvalue|
              define_databag_replacements hash, "#{base}[#{bagkey}]", subkey, subvalue
            end
        end
    end

    def self.subst_path (value, app)
        subst(value, app, true)
    end

    def self.subst_string (value, app)
        subst(value, app, false)
    end

    def self.subst (value, app, is_path = true)
        return nil if value.nil? || value.to_s == ''

        base = Chef::Recipe::Base

        if app
{{#if app.repo}}
            value = value.gsub('@repo', "#{app[:run_as_home]}/#{app[:repo_dir]}")
{{/if}}
            doc_root = (defined?(app[:doc_root]) && app[:doc_root]) ? app[:doc_root] : '@doc_root_undefined'
            run_as = (defined?(app[:run_as]) && app[:run_as]) ? app[:run_as] : '@run_as_undefined'
            run_as_home = (defined?(app[:run_as_home]) && app[:run_as_home]) ? app[:run_as_home] : '@run_as_home_undefined'

            value = value.gsub('@doc_root', doc_root)
            value = value.gsub('@name', app[:name])
            value = value.gsub('@ipaddress', app[:ipaddress])
            value = value.gsub('@hostname', %x(hostname).strip)
            value = value.gsub('@domain', app[:domain]) if app[:domain]
            value = value.gsub('@run_as', run_as)
            value = value.gsub('@home', run_as_home)
            value = value.gsub('@mail_user', app[:mail_user])
            value = value.gsub('@mail_password', app[:mail_password])
            value = value.gsub('@dbname', app[:dbname]) if app[:dbname]
            value = value.gsub('@dbuser', app[:dbuser]) if app[:dbuser]
            value = value.gsub('@dbpass', app[:dbpass]) if app[:dbpass]

            value = value.gsub('@backup_dir', app[:backup_dir]) if app[:backup_dir]
            value = value.gsub('@backup_timestamp', app[:backup_timestamp]) if app[:backup_timestamp]

            (0...9).each do |n|
                value = value.gsub("@uniq[#{n}]", app[:uniq][n])
                value = value.gsub("@rand[#{n}]", app[:rand][n])
            end

            if app[:databag_replacements]
                app[:databag_replacements].each do |find, replace|
                    value = value.gsub(find, replace.to_s)
                end
            end

{{#if app.passwords}}
    {{#each app.passwords}}
            app[:passwords].each do |user, pass|
                 value = value.gsub("@password[#{user}]", app[:passwords][user])
            end
    {{/each}}
{{/if}}

{{#if app.groups}}
    {{#each app.groups}}
            if app[:groups] && app[:groups]['{{group}}']
                value = value.gsub('@group[{{group}}]', app[:groups]['{{group}}'][:name])
            end
    {{/each}}
{{/if}}
{{#if app.users}}
    {{#each app.users}}
            if app[:users] && app[:users]['{{user}}']
                value = value.gsub('@user[{{user}}]', app[:users]['{{user}}'][:name])
            end
    {{/each}}
{{/if}}
        end

        value = value.gsub('@chef_user', base.chef_user)
        value = value.gsub('@chef_home', base.chef_user_home)
        value = value.gsub('@files', "#{base.chef_files(app[:name])}")
        value = value.gsub('@now_millis', (1000*Time.now.to_f).to_i.to_s)
        value = value.gsub('@timezone', %x(cat /etc/timezone).strip) if File.exists? '/etc/timezone'
        value = value.gsub('@web_mode', '{{app.web.mode}}') unless '{{app.web.mode}}'.empty?

        if value.include? '@currency_code'
          money_locale = %x(locale | grep LC_MONETARY | tr '=".' ' ' | awk '{print $2}').strip
          if money_locale.length > 0
            locale_file="/usr/share/i18n/locales/#{money_locale}"
            if File.exists? locale_file
              currency_code = %x(cat #{locale_file} | grep int_curr_symbol | awk '{print $2}' | tr -d '"' | sed -e 's,<U, ,g' | tr -d '>').strip.split(" ").map(&:hex).pack('C*').force_encoding('utf-8').strip
              if currency_code.empty?
                raise "Error determining currency code from #{locale_file}"
              end
              value = value.gsub('@currency_code', currency_code)
            end
          end
        end

        if defined? Chef::Recipe::Java.java_home
            java_home = Chef::Recipe::Java.java_home
            value = value.gsub('@java_home', java_home) unless java_home.nil?
        end

        if app && !value.start_with?('/') && is_path
            value = "#{app[:run_as_home]}/#{value}"
        end

        # Look for function prefixes and process their innards
        { '@lower'  => lambda { |val| val.downcase },
          '@length' => lambda { |val| val.length },
          '@now'    => lambda { |val| Time.now.strftime(val) },
          '@sha256' => lambda { |val| Digest::SHA256.hexdigest(val) },
          '@md5'    => lambda { |val| Digest::MD5.hexdigest(val) },
          '@exec'   => lambda { |val| %x(#{val}).strip } }.each do |fname, func|
            prefix = "#{fname}("
            found = value.index prefix
            while found
                closing_paren = value.index ')', found+1
                inner_value = value[found + prefix.length, closing_paren - found - prefix.length]
                value = value.sub("#{prefix}#{inner_value})", func.call(inner_value))
                found = value.index prefix
            end
        end

        value
    end

    def self.define_group(chef, app, group_name, members_list = nil)
        if members_list
            chef.group group_name do
                action :create
                members "#{members_list.join(',')}"
            end
        else
            chef.group group_name do
                action :create
            end
        end
    end

    def self.group_exists? group_name
        %x(grep '^#{group_name}:' | wc -l).strip
    end

    def self.user(chef, app, user_name, user_home, group_name, can_login, is_system)
        if user_home
            chef.directory user_home do
                owner user_name
                action :create
            end
        end

        user_shell = can_login ? '/bin/bash' : '/usr/sbin/nologin'
        chef.user user_name do
            home user_home
            gid group_name
            shell user_shell
            system is_system
        end

        chef.bash "chown #{user_name} #{user_home}" do
            user 'root'
            code <<-EOH
chown #{user_name} #{user_home}
            EOH
        end
    end

    def self.init_user(chef, app)

        can_login = false
{{#if app.run_as}}
    {{#if app.run_as.user}}
        app[:run_as] = '{{app.run_as.user}}'
    {{/if}}

        can_login = '{{app.run_as.can_login}}' == 'true'
{{else}}
    {{#if app.parent}}
        app[:run_as] = '{{app.parent}}'
    {{/if}}
{{/if}}
        app[:run_as] ||= '{{app.name}}'
        app[:run_as_home] = "/home/#{app[:run_as]}"

        self.user chef, app, app[:run_as], app[:run_as_home], nil, can_login, false

{{#if app.web.doc_root}}
        app[:doc_root] = "#{app[:run_as_home]}/{{app.web.doc_root}}"
{{else}}
        app[:doc_root] = "#{app[:run_as_home]}/{{app.name}}"
{{/if}}
    end

    def self.dir (chef, dir, app)
        dir = subst(dir, app)
        chef.directory dir do
            owner app[:run_as]
            group app[:run_as]
            mode '0755'
            action :create
        end
        permission(chef, dir, app, app[:run_as], app[:run_as], "u+rx")
    end

    def self.template_file(chef, template_src, template_dest, app)
        template_src = File.basename(template_dest) if template_src == '_'
        template_dest = subst(template_dest, app)

        chef.template template_dest do
            source "#{template_src}.erb"
            owner app[:run_as]
            group app[:run_as]
            mode '0700'
            variables ({ :app => app })
            action :create
        end
    end

    def self.symlink(chef, symlink_target, symlink_link, app)

        symlink_link = subst(symlink_link, app)

        target_parts = symlink_target.split
        if target_parts.first == 'which'
            # it's a command and they want us to find the path to it
            command = target_parts.last
            symlink_target = %x(which #{command}).strip
            raise "symlink: Command not found: #{command}" if symlink_target.nil? || symlink_target.empty?
        else
            # otherwise it's a regular path, perform subst on it
            symlink_target = subst(symlink_target, app)
        end

        chef.bash "ln -s #{symlink_target} #{symlink_link}" do
            user 'root'
            code <<-EOH
ln -s #{symlink_target} #{symlink_link}
            EOH
            not_if { File.exists? symlink_link }
        end
    end

    def self.permission(chef, path, app, chown, chgrp, perms, recursive = false)
        target = app.nil? ? path : subst(path, app)
        chown_target = chown.nil? ? nil : ( chown.include?('.') ? chown : (chgrp.nil? ? chown : "#{chown}.#{chgrp}") )
        recursive_flag = recursive ? '-R' : ''
        if chown_target.nil?
            unless chgrp.nil?
                chgrp = subst_string(chgrp, app)
                chef.bash "apply group=#{chgrp} to #{target}, recursive=#{recursive}" do
                    user 'root'
                    code <<-EOH
if [ ! -e "#{target}" ] ; then
  # but only if the target does not contain an asterisk...
  if echo x"#{target}" | grep '*' > /dev/null ; then
    echo "permission: target #{target} contains asterisk, not touching"
    chgrp #{recursive_flag} #{chgrp} #{target}
  else
    touch "#{target}"
    chgrp #{recursive_flag} #{chgrp} "#{target}"
  fi
else
  chgrp #{recursive_flag} #{chgrp} "#{target}"
fi
                    EOH
                end
            end
        else
            chown_target = app.nil? ? chown_target : subst_string(chown_target, app)
            chef.bash "apply ownership=#{chown_target} to #{target}, recursive=#{recursive}" do
                user 'root'
                code <<-EOH
if [ ! -e "#{target}" ] ; then
  # but only if the target does not contain an asterisk...
  if echo x"#{target}" | grep '*' > /dev/null ; then
    echo "permission: target #{target} contains asterisk, not touching"
    chown #{recursive_flag} #{chown_target} #{target}
  else
    touch "#{target}"
    chown #{recursive_flag} #{chown_target} "#{target}"
  fi
else
  chown #{recursive_flag} #{chown_target} "#{target}"
fi
                EOH
            end
        end

        unless perms.nil?
            chef.bash "apply perms=#{perms} to #{target}, recursive=#{recursive}" do
                user 'root'
                code <<-EOH
if [ ! -e "#{target}" ] ; then
  # but only if the target does not contain an asterisk...
  if echo x"#{target}" | grep '*' > /dev/null ; then
    echo "permission: target #{target} contains asterisk, not touching"
    chmod #{recursive_flag} #{perms} #{target}
  else
    touch "#{target}"
    chmod #{recursive_flag} #{perms} "#{target}"
  fi
else
  chmod #{recursive_flag} #{perms} "#{target}"
fi
                EOH
            end
        end
    end

    def self.move(chef, to, from, app)
        to = subst(to, app)
        from = subst(from, app)
        check = to
        check = check + "/#{File.basename from}" if File.directory? to

        chef.bash "mv #{from} #{to}" do
            user 'root'
            code <<-EOH
# check is #{check}
mv #{from} #{to}
            EOH
            only_if { %x(ls -1 #{check}).strip.to_i == 0 }
        end
    end

    def self.copy(chef, to, from, app)
        to = subst(to, app)
        from = subst(from, app)
        chef.bash "rsync -avc #{from} #{to}" do
            user 'root'
            code <<-EOH
rsync -avc #{from} #{to}
            EOH
        end
    end

    def self.append(chef, data, target, app)
        target = subst(target, app)
        chef.bash "appending to #{target}" do
            user 'root'
            code <<-EOH
cat >> #{target} <<EOF
    #{data.gsub('$', '\\\\$')}
EOF
            EOH
            not_if { File.readlines("#{target}").grep(/Regexp.escape(data)/).size > 0 }
        end
    end

    def self.exec (chef, app, exec, exec_user, dir, stdin = nil, unless_file = nil)

        exec = subst_string(exec, app)
        exec_user ||= 'root'
        exec_user = subst_string(exec_user, app)
        dir = (dir.to_s == '') ? app[:run_as_home] : subst(dir, app)
        stdin = subst(stdin, app)
        unless_file = subst(unless_file, app)

        cmd = (stdin.to_s == '') ? exec : "echo '#{self.subst(stdin)}' | #{exec}"
        if cmd.start_with? '@bash'
          cmd = "#{cmd.sub('@bash', 'bash -c "')} #{cmd.gsub('"', '\"')} \""
        end

        chef.bash "exec: #{exec} in #{dir} with stdin #{stdin}" do
            user 'root'
            cwd dir
            code <<-EOH
if [ "#{exec_user}" = 'root' ] ; then
    #{cmd}
else
    sudo -u #{exec_user} -H #{cmd}
fi
            EOH
            only_if { unless_file.to_s == '' || !File.exists?(unless_file) }
        end

    end

    def self.logrotate (chef, app, path)
        base = Chef::Recipe::Base
        path = subst(path, app)
        lr_file = "/etc/logrotate.d/#{app[:name]}_#{base.password(path)}"
        base.logrotate chef, path
    end

    def self.sysinit (chef, app, command)
        svc = app[:service_name]
        init_svc = "/etc/init.d/#{svc}"

        if command.start_with? 'jrun'
            command_parts = command.split(':')
            java_class = command_parts[1]
            java_yml = command_parts[2]
            java_yml = subst(java_yml, app) unless java_yml.nil?
            run_as = command_parts[3]
            run_as = subst_string(run_as, app) unless run_as.nil?
            run_as ||= app[:run_as]

            java = Chef::Recipe::Java
            java.define_service(chef, subst('@name', app), run_as, java_class, java_yml)

        elsif command.start_with? 'wrap'
            command_parts = command.split(':')

            start_script = command_parts[1]
            stop_script = ''
            if start_script.include? ';'
                script_parts = start_script.split(';')
                start_script = subst(script_parts[0], app)
                stop_script = subst(script_parts[1], app)
            else
                start_script = subst(start_script, app)
            end

            pattern = subst_string(command_parts[2], app)
            pattern ||= start_script
            run_as = command_parts[3]
            run_as = subst_string(run_as, app) unless run_as.nil?
            run_as ||= app[:run_as]

            unless File.exists? init_svc
                chef.template init_svc do
                    source "init_wrapper.sh.erb"
                    owner 'root'
                    group 'root'
                    mode '0755'
                    variables({
                        :start_script => start_script,
                        :stop_script => stop_script,
                        :app => app,
                        :pattern => pattern,
                        :run_as => run_as
                    })
                    action :create
                end

                chef.service app[:service_name] do
                    pattern pattern
                    supports [ :start => true, :stop => true ]
                    action [ :enable, :start ]
                end
            end

        else
            command = subst(command, app)

            unless File.exists? init_svc
                chef.template init_svc do
                    source 'init.sh.erb'
                    owner 'root'
                    group 'root'
                    mode '0755'
                    variables({ :command => command, :app => app })
                    action :create
                end

                chef.service svc do
                    pattern command
                    supports [ :start => true, :stop => true ]
                    action [ :enable, :start ]
                end
            end
        end
    end

    def self.service (chef, app, name, pattern, provider = nil)
        pattern = name if pattern.to_s.empty?
        chef.service name do
            pattern pattern
            provider provider
            supports :start => true, :stop => true, :restart => true
            action [ :enable, :restart ]
        end
    end

    def self.user_management (chef, app)
        {{#each app.auth.user_management.templates}}
        script = subst('{{this}}', app)
        chef.template script do
            owner app[:run_as]
            mode '0744'
            variables({ :app => app })
            action :create
        end
        {{/each}}

        chef.directory '/etc/rooty_handlers' do
            owner 'root'
            group 'root'
            mode '0700'
            action :create
        end

        chef.template "/etc/rooty_handlers/#{app[:name]}_user_mgmt.yml" do
            source 'rooty_handler.yml.erb'
            owner 'root'
            group 'root'
            mode '0400'
            variables({ :app => app })
            action :create
        end
    end

    def self.cloudos_group (chef, app, name, description, quota, mirror, members)

        description = "--description '#{subst_string(description, app)}'" unless description.to_s.empty?
        quota       = "--quota       '#{subst_string(quota, app)}'"       unless quota.to_s.empty?
        mirror      = "--mirror      '#{subst_string(mirror, app)}'"      unless mirror.to_s.empty?
        members     = "--members     '#{subst_string(members, app)}'"     unless members.to_s.empty?

        chef.bash "create cloudos_group: #{name} with mirror=#{mirror} and members=#{members}" do
            user 'root'
            cwd '/tmp'
            code <<-EOH
cos sudo --command group --name #{name} #{description} #{quota} #{mirror} #{members}
            EOH
        end
    end
end
